{"version":3,"file":"authkeeper.js","mappings":"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","sources":["webpack://authkeeper/webpack/universalModuleDefinition","webpack://authkeeper/webpack/bootstrap","webpack://authkeeper/webpack/runtime/define property getters","webpack://authkeeper/webpack/runtime/hasOwnProperty shorthand","webpack://authkeeper/webpack/runtime/make namespace object","webpack://authkeeper/./lib/utils/cryptoUtils.js","webpack://authkeeper/./lib/client.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"authkeeper\"] = factory();\n\telse\n\t\troot[\"authkeeper\"] = factory();\n})(self, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// Check if we're running in a browser or Node.js\nconst isBrowser = typeof window !== 'undefined';\n\nclass CryptoUtils {\n    // Generate a random string using JavaScript's built-in crypto (both for Browser and Node.js)\n    static generateRandomString(length = 28) {\n        if (isBrowser) {\n            // Browser: Use the Web Crypto API\n            const array = new Uint32Array(length);\n            window.crypto.getRandomValues(array);\n            return Array.from(array, dec => ('0' + dec.toString(16)).substr(-2)).join('');\n        } else {\n            // Node.js: Use the built-in crypto (only available in Node.js)\n            const array = new Uint8Array(length);\n            require('crypto').randomFillSync(array);\n            return Array.from(array, byte => ('0' + byte.toString(16)).substr(-2)).join('');\n        }\n    }\n\n    // Base64 URL encode a buffer (works for both Node.js and browser)\n    static base64urlencode(buffer) {\n        let base64String;\n        if (isBrowser) {\n            base64String = btoa(String.fromCharCode.apply(null, new Uint8Array(buffer)));\n        } else {\n            base64String = Buffer.from(buffer).toString('base64');\n        }\n\n        return base64String\n            .replace(/\\+/g, '-')\n            .replace(/\\//g, '_')\n            .replace(/=+$/, '');\n    }\n\n    // SHA-256 hashing function (works for both Node.js and browser)\n    static async sha256(plain) {\n        if (isBrowser) {\n            // Browser: Use the Web Crypto API\n            const encoder = new TextEncoder();\n            const data = encoder.encode(plain);\n            const hashed = await window.crypto.subtle.digest('SHA-256', data);\n            return new Uint8Array(hashed);  // Convert ArrayBuffer to Uint8Array\n        } else {\n            // Node.js: Use the built-in crypto (only available in Node.js)\n            const crypto = require('crypto');\n            const hash = crypto.createHash('sha256');\n            hash.update(plain);\n            return hash.digest();  // Return a buffer\n        }\n    }\n\n    // PKCE challenge generation from a verifier\n    static async pkceChallengeFromVerifier(verifier) {\n        const hashed = await this.sha256(verifier);\n        return this.base64urlencode(hashed);\n    }\n\n    // Parse a query string into an object\n    static parseQueryString(query) {\n        const params = new URLSearchParams(query);\n        const result = {};\n        for (let [key, value] of params.entries()) {\n            result[key] = value;\n        }\n        return result;\n    }\n}\n\nexport default CryptoUtils;\n","import CryptoUtils from './utils/cryptoUtils.js';\nimport { getPkceAuthToken } from './grants/pkce-grant.js';\n\nclass OAuthClient {\n    constructor(config) {\n      this.client_id = config.client_id;\n      this.client_secret = config.client_secret;\n      this.redirect_uri = config.redirect_uri;\n      this.authorization_url = config.authorization_url;\n      this.token_url = config.token_url;\n      this.scope = config.scope;\n    }\n\n    async startAuthFlow() {\n      const state = CryptoUtils.generateRandomString();\n      localStorage.setItem(\"pkce_state\", state);\n\n      const codeVerifier = CryptoUtils.generateRandomString();\n      localStorage.setItem(\"pkce_code_verifier\", codeVerifier);\n\n      const codeChallenge = await CryptoUtils.pkceChallengeFromVerifier(codeVerifier);\n\n      const url = `${this.authorization_url}?response_type=code&client_id=${encodeURIComponent(this.client_id)}&state=${encodeURIComponent(state)}&scope=${encodeURIComponent(this.scope)}&redirect_uri=${encodeURIComponent(this.redirect_uri)}&code_challenge=${encodeURIComponent(codeChallenge)}&code_challenge_method=S256`;\n\n      window.location = url;\n      // return url;\n    }\n    \n    // Handle OAuth callback\n    async handleCallback() {\n      const q = CryptoUtils.parseQueryString(window.location.search.substring(1));\n  \n      if (q.error) {\n        alert(\"Error: \" + q.error);\n      }\n  \n      if (q.code) {\n        if (localStorage.getItem(\"pkce_state\") !== q.state) {\n          alert(\"Invalid state\");\n        } else {\n          // Get Auth Token\n          await this.exchangeAuthCodeForToken(q.code);\n        }\n      }\n      // localStorage.removeItem(\"pkce_state\");\n      // localStorage.removeItem(\"pkce_code_verifier\");\n    }\n  \n    async exchangeAuthCodeForToken(code) {\n      const codeVerifier = localStorage.getItem(\"pkce_code_verifier\");\n      if (!codeVerifier) {\n          console.error(\"Code verifier is missing from localStorage.\");\n          return null;\n      }\n  \n      const audience = new URL(\"/api/v2/\", this.token_url).origin;\n      const payload = {\n          client_id: this.client_id,\n          client_secret: this.client_secret, // Include client_secret if required\n          grant_type: \"authorization_code\",\n          code: code,\n          redirect_uri: this.redirect_uri,\n          code_verifier: codeVerifier,\n          audience: audience,\n      };\n  \n      const response = await fetch(this.token_url, {\n          method: \"POST\",\n          headers: {\n              \"Content-Type\": \"application/json\",\n          },\n          body: JSON.stringify(payload),\n      });\n  \n      if (!response.ok) {\n          const errorText = await response.text(); // Get the raw error message if not ok\n          console.error(\"Token exchange failed with status:\", response.status, \"Response:\", errorText);\n          return null; // Return null on failure\n      }\n  \n      let data;\n      try {\n          data = await response.json();\n      } catch (err) {\n          console.error(\"Error parsing response JSON:\", err);\n          return null; // Return null if there was an error parsing\n      }\n  \n      if (!data) {\n          console.error(\"No token data returned.\");\n          return null;\n      }\n  \n      localStorage.setItem(\"auth_token\", data.access_token);\n      localStorage.setItem(\"id_token\", data.id_token);\n      localStorage.setItem(\"expires_in\", data.expires_in.toString());\n  \n      const baseUrl = new URL(this.token_url).origin;\n      const userInfoUrl = `${baseUrl}/userinfo`;\n  \n      const userInfoResponse = await fetch(userInfoUrl, {\n        method: \"GET\",\n          headers: {\n              \"Authorization\": `Bearer ${data.access_token}`,\n          },\n      });\n  \n      if (!userInfoResponse.ok) {\n          const errorText = await userInfoResponse.text();\n          console.error(\"User info request failed with status:\", userInfoResponse.status, \"Response:\", errorText);\n          return null;\n      }\n  \n      let userInfo;\n      try {\n          userInfo = await userInfoResponse.json();\n      } catch (err) {\n          console.error(\"Error parsing user info response JSON:\", err);\n          return null;\n      }\n  \n      localStorage.setItem(\"current_user\", JSON.stringify(userInfo));\n  \n      return {\n        auth_token: data.access_token,\n        id_token: data.id_token,\n        expires_in: data.expires_in,\n        user_info: userInfo,\n    };\n  }\n  }  \n\nexport { OAuthClient };  "],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","isBrowser","window","generateRandomString","length","array","Uint32Array","crypto","getRandomValues","Array","from","dec","toString","substr","join","Uint8Array","require","randomFillSync","byte","base64urlencode","buffer","base64String","btoa","String","fromCharCode","apply","Buffer","replace","sha256","plain","data","TextEncoder","encode","hashed","subtle","digest","hash","createHash","update","pkceChallengeFromVerifier","verifier","this","parseQueryString","query","params","URLSearchParams","result","entries","OAuthClient","constructor","config","client_id","client_secret","redirect_uri","authorization_url","token_url","scope","startAuthFlow","state","localStorage","setItem","codeVerifier","codeChallenge","url","encodeURIComponent","location","handleCallback","q","search","substring","error","alert","code","getItem","exchangeAuthCodeForToken","console","audience","URL","origin","payload","grant_type","code_verifier","response","fetch","method","headers","body","JSON","stringify","ok","errorText","text","status","json","err","access_token","id_token","expires_in","userInfoUrl","userInfoResponse","userInfo","auth_token","user_info"],"sourceRoot":""}