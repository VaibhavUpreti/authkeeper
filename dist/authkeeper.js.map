{"version":3,"file":"authkeeper.js","mappings":"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","sources":["webpack://authkeeper/webpack/universalModuleDefinition","webpack://authkeeper/webpack/bootstrap","webpack://authkeeper/webpack/runtime/define property getters","webpack://authkeeper/webpack/runtime/hasOwnProperty shorthand","webpack://authkeeper/webpack/runtime/make namespace object","webpack://authkeeper/./lib/utils/cryptoUtils.js","webpack://authkeeper/./lib/grants/pkce-grant.js","webpack://authkeeper/./lib/grants/refresh-token.js","webpack://authkeeper/./lib/client.js","webpack://authkeeper/./lib/utils/getEnvironment.js","webpack://authkeeper/./lib/grants/authorization-code.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"authkeeper\"] = factory();\n\telse\n\t\troot[\"authkeeper\"] = factory();\n})(self, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// Check if we're running in a browser or Node.js\nconst isBrowser = typeof window !== 'undefined';\n\nclass CryptoUtils {\n    // Generate a random string using JavaScript's built-in crypto (both for Browser and Node.js)\n    static generateRandomString(length = 28) {\n        if (isBrowser) {\n            // Browser: Use the Web Crypto API\n            const array = new Uint32Array(length);\n            window.crypto.getRandomValues(array);\n            return Array.from(array, dec => ('0' + dec.toString(16)).substr(-2)).join('');\n        } else {\n            // Node.js: Use the built-in crypto (only available in Node.js)\n            const array = new Uint8Array(length);\n            require('crypto').randomFillSync(array);\n            return Array.from(array, byte => ('0' + byte.toString(16)).substr(-2)).join('');\n        }\n    }\n\n    // Base64 URL encode a buffer (works for both Node.js and browser)\n    static base64urlencode(buffer) {\n        let base64String;\n        if (isBrowser) {\n            base64String = btoa(String.fromCharCode.apply(null, new Uint8Array(buffer)));\n        } else {\n            base64String = Buffer.from(buffer).toString('base64');\n        }\n\n        return base64String\n            .replace(/\\+/g, '-')\n            .replace(/\\//g, '_')\n            .replace(/=+$/, '');\n    }\n\n    // SHA-256 hashing function (works for both Node.js and browser)\n    static async sha256(plain) {\n        if (isBrowser) {\n            // Browser: Use the Web Crypto API\n            const encoder = new TextEncoder();\n            const data = encoder.encode(plain);\n            const hashed = await window.crypto.subtle.digest('SHA-256', data);\n            return new Uint8Array(hashed);  // Convert ArrayBuffer to Uint8Array\n        } else {\n            // Node.js: Use the built-in crypto (only available in Node.js)\n            const crypto = require('crypto');\n            const hash = crypto.createHash('sha256');\n            hash.update(plain);\n            return hash.digest();  // Return a buffer\n        }\n    }\n\n    // PKCE challenge generation from a verifier\n    static async pkceChallengeFromVerifier(verifier) {\n        const hashed = await this.sha256(verifier);\n        return this.base64urlencode(hashed);\n    }\n\n    // Parse a query string into an object\n    static parseQueryString(query) {\n        const params = new URLSearchParams(query);\n        const result = {};\n        for (let [key, value] of params.entries()) {\n            result[key] = value;\n        }\n        return result;\n    }\n}\n\nexport default CryptoUtils;\n","import CryptoUtils from '../utils/cryptoUtils.js';\n\n/**\n * Initiates the OAuth 2.0 PKCE Authorization Flow.\n * Generates state and code verifier, stores them in localStorage, and redirects to the authorization URL.\n * @param {Object} config - OAuth configuration.\n */\nexport async function startAuthFlow(config) {\n    const state = CryptoUtils.generateRandomString();\n    localStorage.setItem(\"pkce_state\", state);\n\n    const codeVerifier = CryptoUtils.generateRandomString();\n    localStorage.setItem(\"pkce_code_verifier\", codeVerifier);\n\n    const codeChallenge = await CryptoUtils.pkceChallengeFromVerifier(codeVerifier);\n\n    const url = `${config.authorization_url}?response_type=code&client_id=${encodeURIComponent(config.client_id)}&state=${encodeURIComponent(state)}&scope=${encodeURIComponent(config.scope)}&redirect_uri=${encodeURIComponent(config.redirect_uri)}&code_challenge=${encodeURIComponent(codeChallenge)}&code_challenge_method=S256`;\n\n    window.location = url;\n}\n\n/**\n * Handles the OAuth 2.0 callback and processes the authorization code.\n * @param {Object} config - OAuth configuration.\n * @returns {Object|null} - Token data if successful, null otherwise.\n */\nexport async function handleCallback(config) {\n    const query = CryptoUtils.parseQueryString(window.location.search.substring(1));\n\n    if (query.error) {\n        alert(\"Error: \" + query.error);\n        return null;\n    }\n\n    if (query.code) {\n        if (localStorage.getItem(\"pkce_state\") !== query.state) {\n            alert(\"Invalid state\");\n            return null;\n        }\n        return exchangeAuthCodeForToken(config, query.code);\n    }\n\n    return null;\n}\n\n/**\n * Exchanges the authorization code for tokens.\n * @param {Object} config - OAuth configuration.\n * @param {string} code - Authorization code.\n * @returns {Object|null} - Token data if successful, null otherwise.\n */\nexport async function exchangeAuthCodeForToken(config, code) {\n    const codeVerifier = localStorage.getItem(\"pkce_code_verifier\");\n    if (!codeVerifier) {\n        console.error(\"Code verifier is missing from localStorage.\");\n        return null;\n    }\n\n    const payload = {\n        client_id: config.client_id,\n        grant_type: \"authorization_code\",\n        code,\n        redirect_uri: config.redirect_uri,\n        code_verifier: codeVerifier,\n    };\n\n    const response = await fetch(config.token_url, {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify(payload),\n    });\n\n    if (!response.ok) {\n        console.error(\"Token exchange failed:\", await response.text());\n        return null;\n    }\n\n    const data = await response.json();\n    localStorage.setItem(\"access_token\", data.access_token);\n    localStorage.setItem(\"id_token\", data.id_token);\n    localStorage.setItem(\"expires_in\", data.expires_in.toString());\n    localStorage.setItem(\"refresh_token\", data.refresh_token);\n\n\n    const userInfo = await fetchUserInfo(config, data.access_token);\n    if (userInfo) {\n        localStorage.setItem(\"current_user\", JSON.stringify(userInfo));\n        return {\n            access_token: data.access_token,\n            id_token: data.id_token,\n            expires_in: data.expires_in,\n            user_info: userInfo,\n        };\n    }\n\n    return null;\n}\n\n/**\n * Fetches user information using the access token.\n * @param {Object} config - OAuth configuration.\n * @param {string} accessToken - Access token.\n * @returns {Object|null} - User info if successful, null otherwise.\n */\nasync function fetchUserInfo(config, accessToken) {\n    const baseUrl = new URL(config.token_url).origin;\n    const userInfoUrl = `${baseUrl}/userinfo`;\n\n    const response = await fetch(userInfoUrl, {\n        method: \"GET\",\n        headers: {\n            \"Authorization\": `Bearer ${accessToken}`,\n        },\n    });\n\n    if (!response.ok) {\n        console.error(\"User info request failed:\", await response.text());\n        return null;\n    }\n\n    try {\n        return await response.json();\n    } catch (err) {\n        console.error(\"Error parsing user info response JSON:\", err);\n        return null;\n    }\n}\n","/**\n * Refreshes the access token using the refresh token.\n * @param {Object} config - OAuth configuration.\n * @param {string} refreshToken - The refresh token obtained earlier.\n * @returns {Object|null} - Token data if successful, null otherwise.\n */\nexport async function refreshAccessToken(config, refreshToken) {\n    // Prepare payload for the token refresh request\n    const payload = new URLSearchParams({\n        grant_type: \"refresh_token\",\n        client_id: config.client_id,\n       // client_secret: config.client_secret,\n        refresh_token: refreshToken,\n    });\n\n    // Make the POST request to refresh the token\n    const response = await fetch(config.token_url, {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/x-www-form-urlencoded\", \n        },\n        body: payload.toString(),\n    });\n\n    if (!response.ok) {\n        console.error(\"Refresh token request failed:\", await response.text());\n        return null;\n    }\n\n    // Parse the response to get the tokens\n    const data = await response.json();\n\n    // Store the new tokens in localStorage\n    localStorage.setItem(\"access_token\", data.access_token);\n    localStorage.setItem(\"id_token\", data.id_token);\n    localStorage.setItem(\"expires_in\", data.expires_in.toString());\n\n    return data;\n}","import { getEnvironment } from './utils/getEnvironment.js';\nimport { startAuthFlow as browserStartAuthFlow, handleCallback as browserHandleCallback, exchangeAuthCodeForToken as browserExchangeAuthCodeForToken } from './grants/pkce-grant.js';\nimport { startAuthFlow as serverStartAuthFlow, handleCallback as serverHandleCallback, exchangeAuthCodeForToken as serverExchangeAuthCodeForToken } from './grants/authorization-code.js';\nimport { refreshAccessToken } from './grants/refresh-token.js';\n\nclass OAuthClient {\n    constructor(config, environment = getEnvironment()) {\n        this.config = config;\n        this.environment = environment;\n    }\n\n    async startAuthFlow() {\n        if (this.environment === \"browser\" || this.environment === \"mobile\") {\n            return browserStartAuthFlow(this.config);\n        } else if (this.environment === \"server\") {\n            return serverStartAuthFlow(this.config);\n        } else {\n            throw new Error(`Unknown environment: ${this.environment}`);\n        }\n    }\n\n    async handleCallback() {\n        if (this.environment === \"browser\" || this.environment === \"mobile\") {\n            return browserHandleCallback(this.config);\n        } else if (this.environment === \"server\") {\n            return serverHandleCallback(this.config);\n        } else {\n            throw new Error(`Unknown environment: ${this.environment}`);\n        }\n    }\n\n    async exchangeAuthCodeForToken(code) {\n        if (this.environment === \"browser\" || this.environment === \"mobile\") {\n            return browserExchangeAuthCodeForToken(this.config, code);\n        } else if (this.environment === \"server\") {\n            return serverExchangeAuthCodeForToken(this.config, code);\n        } else {\n            throw new Error(`Unknown environment: ${this.environment}`);\n        }\n    }\n\n    async refreshAccessToken(refreshToken) {\n        if (this.environment === \"browser\" || this.environment === \"mobile\") {\n          const refreshToken = localStorage.getItem('refresh_token');\n          return refreshAccessToken(this.config, refreshToken);\n          } else if (this.environment === \"server\") {\n            return refreshAccessToken(this.config, refreshToken);\n        } else {\n            throw new Error(`Unknown environment: ${this.environment}`);\n        }\n    }\n}\n\nexport { OAuthClient };\n\n\n\n// import CryptoUtils from './utils/cryptoUtils.js';\n// import { getPkceAuthToken } from './grants/pkce-grant.js';\n\n// class OAuthClient {\n//     constructor(config) {\n//       this.client_id = config.client_id;\n//       this.client_secret = config.client_secret;\n//       this.redirect_uri = config.redirect_uri;\n//       this.authorization_url = config.authorization_url;\n//       this.token_url = config.token_url;\n//       this.scope = config.scope;\n//     }\n\n//     async startAuthFlow() {\n//       const state = CryptoUtils.generateRandomString();\n//       localStorage.setItem(\"pkce_state\", state);\n\n//       const codeVerifier = CryptoUtils.generateRandomString();\n//       localStorage.setItem(\"pkce_code_verifier\", codeVerifier);\n\n//       const codeChallenge = await CryptoUtils.pkceChallengeFromVerifier(codeVerifier);\n\n//       const url = `${this.authorization_url}?response_type=code&client_id=${encodeURIComponent(this.client_id)}&state=${encodeURIComponent(state)}&scope=${encodeURIComponent(this.scope)}&redirect_uri=${encodeURIComponent(this.redirect_uri)}&code_challenge=${encodeURIComponent(codeChallenge)}&code_challenge_method=S256`;\n\n//       window.location = url;\n//       // return url;\n//     }\n    \n//     // Handle OAuth callback\n//     async handleCallback() {\n//       const q = CryptoUtils.parseQueryString(window.location.search.substring(1));\n  \n//       if (q.error) {\n//         alert(\"Error: \" + q.error);\n//       }\n  \n//       if (q.code) {\n//         if (localStorage.getItem(\"pkce_state\") !== q.state) {\n//           alert(\"Invalid state\");\n//         } else {\n//           // Get Auth Token\n//           await this.exchangeAuthCodeForToken(q.code);\n//         }\n//       }\n//       // localStorage.removeItem(\"pkce_state\");\n//       // localStorage.removeItem(\"pkce_code_verifier\");\n//     }\n  \n//     async exchangeAuthCodeForToken(code) {\n//       const codeVerifier = localStorage.getItem(\"pkce_code_verifier\");\n//       if (!codeVerifier) {\n//           console.error(\"Code verifier is missing from localStorage.\");\n//           return null;\n//       }\n  \n//       const audience = new URL(\"/api/v2/\", this.token_url).origin;\n//       const payload = {\n//           client_id: this.client_id,\n//           client_secret: this.client_secret, // Include client_secret if required\n//           grant_type: \"authorization_code\",\n//           code: code,\n//           redirect_uri: this.redirect_uri,\n//           code_verifier: codeVerifier,\n//           audience: audience,\n//       };\n  \n//       const response = await fetch(this.token_url, {\n//           method: \"POST\",\n//           headers: {\n//               \"Content-Type\": \"application/json\",\n//           },\n//           body: JSON.stringify(payload),\n//       });\n  \n//       if (!response.ok) {\n//           const errorText = await response.text(); // Get the raw error message if not ok\n//           console.error(\"Token exchange failed with status:\", response.status, \"Response:\", errorText);\n//           return null; // Return null on failure\n//       }\n  \n//       let data;\n//       try {\n//           data = await response.json();\n//       } catch (err) {\n//           console.error(\"Error parsing response JSON:\", err);\n//           return null; // Return null if there was an error parsing\n//       }\n  \n//       if (!data) {\n//           console.error(\"No token data returned.\");\n//           return null;\n//       }\n  \n//       localStorage.setItem(\"auth_token\", data.access_token);\n//       localStorage.setItem(\"id_token\", data.id_token);\n//       localStorage.setItem(\"expires_in\", data.expires_in.toString());\n  \n//       const baseUrl = new URL(this.token_url).origin;\n//       const userInfoUrl = `${baseUrl}/userinfo`;\n  \n//       const userInfoResponse = await fetch(userInfoUrl, {\n//         method: \"GET\",\n//           headers: {\n//               \"Authorization\": `Bearer ${data.access_token}`,\n//           },\n//       });\n  \n//       if (!userInfoResponse.ok) {\n//           const errorText = await userInfoResponse.text();\n//           console.error(\"User info request failed with status:\", userInfoResponse.status, \"Response:\", errorText);\n//           return null;\n//       }\n  \n//       let userInfo;\n//       try {\n//           userInfo = await userInfoResponse.json();\n//       } catch (err) {\n//           console.error(\"Error parsing user info response JSON:\", err);\n//           return null;\n//       }\n  \n//       localStorage.setItem(\"current_user\", JSON.stringify(userInfo));\n  \n//       return {\n//         auth_token: data.access_token,\n//         id_token: data.id_token,\n//         expires_in: data.expires_in,\n//         user_info: userInfo,\n//     };\n//   }\n//   }  \n\n// export { OAuthClient };  ","// utils/getEnvironment.js\nexport function getEnvironment() {\n    // Check for browser or server environment\n    if (typeof window !== \"undefined\" && typeof window.document !== \"undefined\") {\n        return \"browser\"; // In the browser\n    } else {\n        return \"server\"; // In a server environment\n    }\n}\n","export async function startAuthFlow(config) {\n    const url = `${config.authorization_url}?response_type=code&client_id=${encodeURIComponent(config.client_id)}&scope=${encodeURIComponent(config.scope)}&redirect_uri=${encodeURIComponent(config.redirect_uri)}`;\n    return url; // Server-side apps typically return the URL to the client\n}\n\nexport async function handleCallback(config) {\n    throw new Error(\"Server environment does not directly handle callbacks. Ensure the client sends the code to the server.\");\n}\n\nexport async function exchangeAuthCodeForToken(config, code) {\n    const payload = {\n        client_id: config.client_id,\n        client_secret: config.client_secret,\n        grant_type: \"authorization_code\",\n        code,\n        redirect_uri: config.redirect_uri,\n    };\n\n    const response = await fetch(config.token_url, {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify(payload),\n    });\n\n    if (!response.ok) {\n        console.error(\"Token exchange failed:\", await response.text());\n        return null;\n    }\n\n    return response.json();\n}\n"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","isBrowser","window","generateRandomString","length","array","Uint32Array","crypto","getRandomValues","Array","from","dec","toString","substr","join","Uint8Array","require","randomFillSync","byte","base64urlencode","buffer","base64String","btoa","String","fromCharCode","apply","Buffer","replace","sha256","plain","data","TextEncoder","encode","hashed","subtle","digest","hash","createHash","update","pkceChallengeFromVerifier","verifier","this","parseQueryString","query","params","URLSearchParams","result","entries","async","exchangeAuthCodeForToken","config","code","codeVerifier","localStorage","getItem","console","error","payload","client_id","grant_type","redirect_uri","code_verifier","response","fetch","token_url","method","headers","body","JSON","stringify","ok","text","json","setItem","access_token","id_token","expires_in","refresh_token","userInfo","accessToken","userInfoUrl","URL","origin","err","fetchUserInfo","user_info","refreshAccessToken","refreshToken","OAuthClient","constructor","environment","document","getEnvironment","startAuthFlow","state","codeChallenge","url","authorization_url","encodeURIComponent","scope","location","Error","handleCallback","search","substring","alert","client_secret"],"sourceRoot":""}